/**
 * Character Thoughts Rendering Module
 * Handles rendering of character thoughts panel and floating thought bubbles in chat
 */
import { getContext } from '../../../../../../extensions.js';
import { this_chid, characters } from '../../../../../../../script.js';
import { selected_group, getGroupMembers } from '../../../../../../group-chats.js';
import {
    extensionSettings,
    lastGeneratedData,
    committedTrackerData,
    $thoughtsContainer,
    FALLBACK_AVATAR_DATA_URI,
    addDebugLog
} from '../../core/state.js';
import { saveChatData, saveSettings } from '../../core/persistence.js';
import { getSafeThumbnailUrl } from '../../utils/avatars.js';
import { isItemLocked, setItemLock } from '../generation/lockManager.js';
/**
 * Helper to generate lock icon HTML if setting is enabled
 * @param {string} tracker - Tracker name
 * @param {string} path - Item path
 * @returns {string} Lock icon HTML or empty string
 */
function getLockIconHtml(tracker, path) {
    const showLockIcons = extensionSettings.showLockIcons ?? true;
    if (!showLockIcons) return '';
    const isLocked = isItemLocked(tracker, path);
    const lockIcon = isLocked ? 'üîí' : 'üîì';
    const lockTitle = isLocked ? 'Locked' : 'Unlocked';
    const lockedClass = isLocked ? ' locked' : '';
    return `<span class="rpg-section-lock-icon${lockedClass}" data-tracker="${tracker}" data-path="${path}" title="${lockTitle}">${lockIcon}</span>`;
}
/**
 * Helper to log to both console and debug logs array
 */
function debugLog(message, data = null) {
    if (extensionSettings.debugMode) {
        addDebugLog(message, data);
    }
}
/**
 * Interpolates color based on percentage value between low and high colors
 * @param {number} percentage - Value from 0-100
 * @param {string} lowColor - Hex color for low values (e.g., '#ff0000')
 * @param {string} highColor - Hex color for high values (e.g., '#00ff00')
 * @param {number} lowOpacity - Opacity for low values (0-100)
 * @param {number} highOpacity - Opacity for high values (0-100)
 * @returns {string} Interpolated rgba color
 */
function getStatColor(percentage, lowColor, highColor, lowOpacity = 100, highOpacity = 100) {
    // Clamp percentage to 0-100
    const percent = Math.max(0, Math.min(100, percentage)) / 100;
    // Parse hex colors
    const parseHex = (hex) => {
        const clean = hex.replace('#', '');
        return {
            r: parseInt(clean.substring(0, 2), 16),
            g: parseInt(clean.substring(2, 4), 16),
            b: parseInt(clean.substring(4, 6), 16)
        };
    };
    const low = parseHex(lowColor);
    const high = parseHex(highColor);
    // Interpolate each channel
    const r = Math.round(low.r + (high.r - low.r) * percent);
    const g = Math.round(low.g + (high.g - low.g) * percent);
    const b = Math.round(low.b + (high.b - low.b) * percent);
    const a = (lowOpacity + (highOpacity - lowOpacity) * percent) / 100;
    return `rgba(${r}, ${g}, ${b}, ${a})`;
}
/**
 * Strips leading and trailing square brackets from a string value.
 * Used to clean placeholder notation that AI might include in responses.
 * @param {string} value - The value to clean
 * @returns {string} Cleaned value without surrounding brackets
 */
function stripBrackets(value) {
    if (typeof value !== 'string') return value;
    return value.replace(/^\[|\]$/g, '').trim();
}
/**
 * Extracts the actual value from a field that might be locked.
 * If the field is an object with {value, locked}, returns the value.
 * Otherwise returns the field as-is.
 * @param {any} fieldValue - The field value (might be string or {value, locked} object)
 * @returns {string} The actual string value
 */
function extractFieldValue(fieldValue) {
    if (fieldValue && typeof fieldValue === 'object' && 'value' in fieldValue) {
        return fieldValue.value || '';
    }
    return fieldValue || '';
}
/**
 * Converts a field name to snake_case for use as JSON key
 * Example: "Test Tracker" -> "test_tracker"
 * @param {string} name - Field name to convert
 * @returns {string} snake_case version
 */
function toSnakeCase(name) {
    return name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '');
}
/**
 * Fuzzy name matching that handles:
 * - Exact matches: "Sabrina" === "Sabrina"
 * - Parenthetical additions: "Sabrina" matches "Sabrina (Margrokha's Avatar)"
 * - Title additions: "Sabrina" matches "Princess Sabrina"
 * - Word boundaries: "Sabrina" won't match "Sabrina's Mother"
 *
 * @param {string} cardName - Name from the character card
 * @param {string} aiName - Name generated by the AI
 * @returns {boolean} True if names match
 */
function namesMatch(cardName, aiName) {
    if (!cardName || !aiName) return false;
    // 1. Exact match (fast path)
    if (cardName.toLowerCase() === aiName.toLowerCase()) return true;
    // 2. Strip parentheses and match
    const stripParens = (s) => s.replace(/\s*\([^)]*\)/g, '').trim();
    const cardCore = stripParens(cardName).toLowerCase();
    const aiCore = stripParens(aiName).toLowerCase();
    if (cardCore === aiCore) return true;
    // 3. Check if card name appears as complete word in AI name
    // Escape special regex characters to prevent "Invalid regular expression" errors
    const escapedCardCore = cardCore.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const wordBoundary = new RegExp(`\\b${escapedCardCore}\\b`);
    return wordBoundary.test(aiCore);
}
/**
 * Registers delegated event handlers on $thoughtsContainer ONCE.
 * Uses event delegation so handlers survive DOM replacement via .html().
 * Call this once during init, after $thoughtsContainer is set.
 */
export function initThoughtsEventDelegation() {
    if (!$thoughtsContainer || !$thoughtsContainer.length) return;
    // Editable field blur ‚Äî update character data
    $thoughtsContainer.on('blur', '.rpg-editable', function() {
        const $this = $(this);
        const character = $this.data('character');
        const field = $this.data('field');
        const value = $this.text().trim();
        if (character && field) {
            updateCharacterField(character, field, value);
        }
        // Restore placeholder if field becomes empty
        if (!value && field) {
            $this.addClass('rpg-empty-field');
            $this.attr('data-placeholder', field);
        }
    });
    // Prevent click events on editable elements from bubbling to avatar upload handler
    $thoughtsContainer.on('click mousedown', '.rpg-editable', function(e) {
        e.stopPropagation();
    });
    // Empty field focus - remove placeholder styling
    $thoughtsContainer.on('focus', '.rpg-editable.rpg-empty-field', function() {
        $(this).removeClass('rpg-empty-field');
        $(this).removeAttr('data-placeholder');
    });
    // Lock icon toggle (support both click and touch)
    $thoughtsContainer.on('click touchend', '.rpg-section-lock-icon', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const $icon = $(this);
        const trackerType = $icon.data('tracker');
        const itemPath = $icon.data('path');
        const currentlyLocked = isItemLocked(trackerType, itemPath);
        setItemLock(trackerType, itemPath, !currentlyLocked);
        const newIcon = !currentlyLocked ? 'üîí' : 'üîì';
        const newTitle = !currentlyLocked ? 'Locked' : 'Unlocked';
        $icon.text(newIcon);
        $icon.attr('title', newTitle);
        $icon.toggleClass('locked', !currentlyLocked);
        saveSettings();
    });
    // Character remove button
    $thoughtsContainer.on('click', '.rpg-character-remove', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const characterName = $(this).data('character');
        removeCharacter(characterName);
    });
    // Avatar click ‚Äî flip the card (avatar is now a flip trigger, not upload)
    $thoughtsContainer.on('click', '.rpg-character-avatar', function(e) {
        e.preventDefault();
        e.stopPropagation();
        $(this).closest('.rpg-card-flipper').toggleClass('flipped');
    });
    // Avatar upload ‚Äî small camera icon button in the corner of the avatar
    $thoughtsContainer.on('click', '.rpg-avatar-upload-btn', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const characterName = $(this).closest('.rpg-character-avatar').data('character');
        const fileInput = $('<input type="file" accept="image/*" style="display: none;">');
        fileInput.on('change', function() {
            const file = this.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                const imageUrl = evt.target.result;
                if (!extensionSettings.npcAvatars) {
                    extensionSettings.npcAvatars = {};
                }
                extensionSettings.npcAvatars[characterName] = imageUrl;
                saveSettings();
                const $avatar = $thoughtsContainer.find(`.rpg-character-avatar[data-character="${characterName}"] img`);
                $avatar.attr('src', imageUrl);
                if (extensionSettings.debugMode) console.log(`[Dooms Tracker] Avatar uploaded for ${characterName}`);
            };
            reader.readAsDataURL(file);
        });
        fileInput.trigger('click');
    });
    // "Add Character" button (support both click and touch for mobile)
    $thoughtsContainer.on('click touchend', '.rpg-add-character-btn', function(e) {
        e.preventDefault();
        e.stopPropagation();
        addNewCharacter();
    });
    // Card flip ‚Äî left click on card background (not interactive children) toggles front/back
    $thoughtsContainer.on('click', '.rpg-card-flipper', function(e) {
        // Don't flip if click originated from an interactive child
        if ($(e.target).closest('.rpg-editable, .rpg-character-avatar, .rpg-avatar-upload-btn, .rpg-character-remove, .rpg-section-lock-icon, .rpg-add-character-btn, button').length) {
            return;
        }
        $(this).toggleClass('flipped');
    });
}
/**
 * Renders character thoughts (Present Characters) panel.
 * Displays character cards with avatars, relationship badges, and traits.
 * Event listeners are registered once via initThoughtsEventDelegation().
 */
export function renderThoughts({ preserveScroll = false } = {}) {
    if (!extensionSettings.showCharacterThoughts || !$thoughtsContainer) {
        return;
    }
    // Save scroll position before re-render if requested
    let savedContentScroll = 0;
    if (preserveScroll) {
        const $content = $thoughtsContainer.find('.rpg-thoughts-content');
        if ($content.length) {
            savedContentScroll = $content[0].scrollTop;
        }
    }
    // Don't render if no data exists (e.g., after cache clear)
    const thoughtsData = lastGeneratedData.characterThoughts || committedTrackerData.characterThoughts;
    if (!thoughtsData) {
        $thoughtsContainer.html('<div class="rpg-inventory-empty">No character data generated yet</div>');
        return;
    }
    debugLog('[RPG Thoughts] ==================== RENDERING PRESENT CHARACTERS ====================');
    debugLog('[RPG Thoughts] showCharacterThoughts setting:', extensionSettings.showCharacterThoughts);
    debugLog('[RPG Thoughts] Container exists:', !!$thoughtsContainer);
    // Add updating class for animation
    if (extensionSettings.enableAnimations) {
        $thoughtsContainer.addClass('rpg-content-updating');
    }
    // Get tracker configuration
    const config = extensionSettings.trackerConfig?.presentCharacters;
    const enabledFields = config?.customFields?.filter(f => f && f.enabled && f.name) || [];
    const characterStatsConfig = config?.characterStats;
    const enabledCharStats = characterStatsConfig?.enabled && characterStatsConfig?.customStats?.filter(s => s && s.enabled && s.name) || [];
    const relationshipFields = config?.relationshipFields || [];
    const hasRelationshipEnabled = relationshipFields.length > 0;
    // Use committedTrackerData as fallback if lastGeneratedData is empty (e.g., after page refresh)
    const characterThoughtsData = lastGeneratedData.characterThoughts || committedTrackerData.characterThoughts || '';
    debugLog('[RPG Thoughts] Raw characterThoughts data:', characterThoughtsData);
    debugLog('[RPG Thoughts] Data length:', characterThoughtsData.length + ' chars');
    debugLog('[RPG Thoughts] Enabled custom fields:', enabledFields.map(f => f.name));
    debugLog('[RPG Thoughts] Enabled character stats:', enabledCharStats.map(s => s.name));
    let presentCharacters = [];
    // Try parsing as JSON first (new format)
    try {
        const parsed = typeof characterThoughtsData === 'string'
            ? JSON.parse(characterThoughtsData)
            : characterThoughtsData;
        // Handle both {characters: [...]} and direct array formats
        const charactersArray = Array.isArray(parsed) ? parsed : (parsed.characters || []);
        if (charactersArray.length > 0) {
            // JSON format: array of character objects
            presentCharacters = charactersArray.map(char => {
                const character = {
                    name: char.name,
                    emoji: char.emoji || 'üë§'
                };
                // Extract details (appearance, demeanor, etc.)
                if (char.details) {
                    // Map details object to custom fields
                    for (const field of enabledFields) {
                        // First try exact field name (for manually edited values)
                        if (char.details[field.name] !== undefined) {
                            character[field.name] = stripBrackets(char.details[field.name]);
                        } else {
                            // Fall back to snake_case for AI-generated values
                            const fieldKey = toSnakeCase(field.name);
                            if (char.details[fieldKey] !== undefined) {
                                character[field.name] = stripBrackets(char.details[fieldKey]);
                            }
                        }
                    }
                }
                // Also check for fields at root level (for backward compatibility)
                // Only use if not already set from details
                for (const field of enabledFields) {
                    if (character[field.name] === undefined) {
                        const fieldKey = toSnakeCase(field.name);
                        if (char[fieldKey] !== undefined) {
                            character[field.name] = stripBrackets(char[fieldKey]);
                        }
                    }
                }
                // Extract relationship
                // Prefer the new flat format (char.Relationship) over the old nested format (char.relationship.status)
                if (char.Relationship) {
                    character.Relationship = stripBrackets(char.Relationship);
                } else if (char.relationship) {
                    character.Relationship = stripBrackets(char.relationship.status || char.relationship);
                }
                // Extract thoughts content for bubble display
                if (char.thoughts) {
                    character.ThoughtsContent = stripBrackets(char.thoughts.content || char.thoughts);
                }
                // Extract character stats if present
                if (char.stats && enabledCharStats.length > 0) {
                    // Handle both object format {Health: 100, Energy: 95} and array format [{name: "Health", value: 100}]
                    if (Array.isArray(char.stats)) {
                        // Array format: [{name: "Health", value: 100}, {name: "Energy", value: 95}]
                        for (const statObj of char.stats) {
                            if (statObj.name && statObj.value !== undefined) {
                                const matchingStat = enabledCharStats.find(s => s.name === statObj.name);
                                if (matchingStat) {
                                    character[statObj.name] = statObj.value;
                                }
                            }
                        }
                    } else {
                        // Object format: {Health: 100, Energy: 95}
                        for (const stat of enabledCharStats) {
                            if (char.stats[stat.name] !== undefined) {
                                character[stat.name] = char.stats[stat.name];
                            }
                        }
                    }
                }
                return character;
            });
            debugLog('[RPG Thoughts] ‚úì Parsed JSON format, characters:', presentCharacters.length);
        }
    } catch (e) {
        debugLog('[RPG Thoughts] Not JSON format, falling back to text parsing');
    }
    // If JSON parsing failed or returned empty, try text format
    if (presentCharacters.length === 0) {
        const lines = characterThoughtsData.split('\n');
        debugLog('[RPG Thoughts] Split into lines count:', lines.length);
        debugLog('[RPG Thoughts] Lines:', lines);
    // Parse new multi-line format:
    // - [Name]
    // Details: [Emoji] | [Field1] | [Field2] | ...
    // Relationship: [Relationship]
    // Stats: Stat1: X% | Stat2: X% | ...
    // Thoughts: [Description]
    let lineNumber = 0;
    let currentCharacter = null;
    for (const line of lines) {
        lineNumber++;
        // Skip empty lines, headers, dividers, and code fences
        if (!line.trim() ||
            line.includes('Present Characters') ||
            line.includes('---') ||
            line.trim().startsWith('```') ||
            line.trim() === '- ‚Ä¶' ||
            line.includes('(Repeat the format')) {
            continue;
        }
        debugLog(`[RPG Thoughts] Processing line ${lineNumber}:`, line);
        // Check if this is a character name line (starts with "- ")
        if (line.trim().startsWith('- ')) {
            const name = line.trim().substring(2).trim();
            if (name && name.toLowerCase() !== 'unavailable') {
                currentCharacter = { name };
                presentCharacters.push(currentCharacter);
                debugLog(`[RPG Thoughts] ‚úì Started new character: ${name}`);
            } else {
                currentCharacter = null;
                debugLog(`[RPG Thoughts] ‚úó Rejected character - name: "${name}" (unavailable or empty)`);
            }
        }
        // Check if this is a Details line
        else if (line.trim().startsWith('Details:') && currentCharacter) {
            const detailsContent = line.substring(line.indexOf(':') + 1).trim();
            const parts = detailsContent.split('|').map(p => p.trim());
            // First part is the emoji
            if (parts.length > 0) {
                currentCharacter.emoji = parts[0];
                debugLog(`[RPG Thoughts] Parsed emoji: ${parts[0]}`);
            }
            // Remaining parts are custom fields
            for (let i = 0; i < enabledFields.length && i + 1 < parts.length; i++) {
                const fieldName = enabledFields[i].name;
                currentCharacter[fieldName] = parts[i + 1];
                debugLog(`[RPG Thoughts] Parsed field ${fieldName}: ${parts[i + 1]}`);
            }
        }
        // Check if this is a Relationship line
        else if (line.trim().startsWith('Relationship:') && currentCharacter) {
            const relationship = line.substring(line.indexOf(':') + 1).trim();
            currentCharacter.Relationship = relationship;
            debugLog(`[RPG Thoughts] Parsed relationship: ${relationship}`);
        }
        // Check if this is a Stats line
        else if (line.trim().startsWith('Stats:') && currentCharacter && enabledCharStats.length > 0) {
            const statsContent = line.substring(line.indexOf(':') + 1).trim();
            const statParts = statsContent.split('|').map(p => p.trim());
            for (const statPart of statParts) {
                const statMatch = statPart.match(/^(.+?):\s*(\d+)%$/);
                if (statMatch) {
                    const statName = statMatch[1].trim();
                    const statValue = parseInt(statMatch[2]);
                    currentCharacter[statName] = statValue;
                    debugLog(`[RPG Thoughts] Parsed stat: ${statName} = ${statValue}%`);
                }
            }
        }
        // Check if this is a Thoughts line (handled separately for thought bubbles)
        else if (line.trim().match(/^[A-Z][a-z]+:/) && currentCharacter) {
            // This could be Thoughts, Feelings, etc. - skip for now, handled in thought bubble rendering
            debugLog(`[RPG Thoughts] Skipping thoughts/feelings line (handled in bubble rendering)`);
        }
    }
    } // End of text format parsing
    // Get relationship emojis from config (with fallback defaults)
    const relationshipEmojis = config?.relationshipEmojis || {
        'Enemy': '‚öîÔ∏è',
        'Neutral': '‚öñÔ∏è',
        'Friend': '‚≠ê',
        'Lover': '‚ù§Ô∏è'
    };
    debugLog('[RPG Thoughts] ==================== PARSING COMPLETE ====================');
    debugLog('[RPG Thoughts] Total characters parsed:', presentCharacters.length);
    debugLog('[RPG Thoughts] Characters array:', presentCharacters);

    // Filter out off-scene characters ‚Äî the AI sometimes includes characters
    // who aren't actually present, with thoughts like "Not in scene" or "Off-scene"
    const offScenePatterns = /\b(not\s+(currently\s+)?(in|at|present|in\s+the)\s+(the\s+)?(scene|area|room|location|vicinity))\b|\b(off[\s-]?scene)\b|\b(not\s+present)\b|\b(absent)\b|\b(away\s+from\s+(the\s+)?scene)\b/i;
    const beforeFilter = presentCharacters.length;
    presentCharacters = presentCharacters.filter(char => {
        const thoughts = char.ThoughtsContent || '';
        if (thoughts && offScenePatterns.test(thoughts)) {
            debugLog(`[RPG Thoughts] Filtering out off-scene character: ${char.name} (thoughts: "${thoughts}")`);
            return false;
        }
        return true;
    });
    if (presentCharacters.length < beforeFilter) {
        debugLog(`[RPG Thoughts] Filtered ${beforeFilter - presentCharacters.length} off-scene characters`);
    }

    // Build HTML
    let html = '';
    debugLog('[RPG Thoughts] ==================== BUILDING HTML ====================');
    debugLog('[RPG Thoughts] Starting HTML generation for', presentCharacters.length + ' characters');
    // If no characters parsed, show empty state (no placeholder)
    if (presentCharacters.length === 0) {
        debugLog('[RPG Thoughts] ‚ö† No characters parsed - showing empty state');
        html += '<div class="rpg-thoughts-content"></div>';
    } else {
        html += '<div class="rpg-thoughts-content">';
        let characterIndex = 0;
        for (const char of presentCharacters) {
            characterIndex++;
            try {
                debugLog(`[RPG Thoughts] Building HTML for character ${characterIndex}/${presentCharacters.length}:`, char.name);
                // Find character portrait
                // Use a base64-encoded SVG placeholder as fallback to avoid 400 errors
                let characterPortrait = FALLBACK_AVATAR_DATA_URI;
                debugLog(`[RPG Thoughts] Looking up avatar for: ${char.name}`);
                // First, check if user manually uploaded a custom avatar
                if (extensionSettings.npcAvatars && extensionSettings.npcAvatars[char.name]) {
                    characterPortrait = extensionSettings.npcAvatars[char.name];
                    debugLog('[RPG Thoughts] Found custom uploaded avatar');
                }
                // For group chats, search through group members
                if (characterPortrait === FALLBACK_AVATAR_DATA_URI && selected_group) {
                    debugLog('[RPG Thoughts] In group chat, checking group members...');
                    try {
                        const groupMembers = getGroupMembers(selected_group);
                        debugLog('[RPG Thoughts] Group members count:', groupMembers ? groupMembers.length : 0);
                        if (groupMembers && groupMembers.length > 0) {
                            const matchingMember = groupMembers.find(member =>
                                member && member.name && namesMatch(member.name, char.name)
                            );
                            if (matchingMember && matchingMember.avatar && matchingMember.avatar !== 'none') {
                                const thumbnailUrl = getSafeThumbnailUrl('avatar', matchingMember.avatar);
                                if (thumbnailUrl) {
                                    characterPortrait = thumbnailUrl;
                                    debugLog('[RPG Thoughts] Found avatar in group members');
                                }
                            }
                        }
                    } catch (groupError) {
                        debugLog('[RPG Thoughts] Error checking group members:', groupError.message);
                    }
                }
                // For regular chats or if not found in group, search all characters
                if (characterPortrait === FALLBACK_AVATAR_DATA_URI && characters && characters.length > 0) {
                    debugLog('[RPG Thoughts] Searching all characters...');
                    const matchingCharacter = characters.find(c =>
                        c && c.name && namesMatch(c.name, char.name)
                    );
                    if (matchingCharacter && matchingCharacter.avatar && matchingCharacter.avatar !== 'none') {
                        const thumbnailUrl = getSafeThumbnailUrl('avatar', matchingCharacter.avatar);
                        if (thumbnailUrl) {
                            characterPortrait = thumbnailUrl;
                            debugLog('[RPG Thoughts] Found avatar in all characters');
                        }
                    }
                }
                // If this is the current character in a 1-on-1 chat, use their portrait
                if (this_chid !== undefined && characters[this_chid] &&
                    characters[this_chid].name && namesMatch(characters[this_chid].name, char.name)) {
                    const thumbnailUrl = getSafeThumbnailUrl('avatar', characters[this_chid].avatar);
                    if (thumbnailUrl) {
                        characterPortrait = thumbnailUrl;
                        debugLog('[RPG Thoughts] Found avatar from current character');
                    }
                }
                debugLog(`[RPG Thoughts] Final avatar for ${char.name}:`, characterPortrait.substring(0, 50) + '...');
                // Get relationship badge - only if relationships are enabled in config
                let relationshipBadge = '‚öñÔ∏è'; // Default
                let relationshipFieldName = 'Relationship';
                if (hasRelationshipEnabled) {
                    // In the new format, relationship is always stored in char.Relationship
                    if (char.Relationship) {
                        // Try to map text to emoji
                        relationshipBadge = relationshipEmojis[char.Relationship] || char.Relationship;
                    }
                }
                debugLog(`[RPG Thoughts] Building HTML card for ${char.name}...`);

                // ‚îÄ‚îÄ FRONT FACE (existing card, wrapped in flipper) ‚îÄ‚îÄ
                html += `
                    <div class="rpg-card-flipper" data-character-name="${char.name}">
                    <div class="rpg-card-inner">
                    <div class="rpg-card-front rpg-character-card">
                        <div class="rpg-character-header-row">
                            <div class="rpg-character-avatar" data-character="${char.name}" title="Click to flip card">
                                <img src="${characterPortrait}" alt="${char.name}" onerror="this.style.opacity='0.5';this.onerror=null;" />
                                <button class="rpg-avatar-upload-btn" title="Upload avatar">üì∑</button>
                                ${hasRelationshipEnabled ? `<div class="rpg-relationship-badge rpg-editable" contenteditable="true" data-character="${char.name}" data-field="${relationshipFieldName}" title="Click to edit (use emoji: ‚öîÔ∏è ‚öñÔ∏è ‚≠ê ‚ù§Ô∏è)">${relationshipBadge}</div>` : ''}
                            </div>
                            <div class="rpg-character-header">
                                <span class="rpg-character-emoji rpg-editable" contenteditable="true" data-character="${char.name}" data-field="emoji" title="Click to edit emoji">${char.emoji}</span>
                                <span class="rpg-character-name rpg-editable" contenteditable="true" data-character="${char.name}" data-field="name" title="Click to edit name">${char.name}</span>
                                <button class="rpg-character-remove" data-character="${char.name}" title="Remove character">√ó</button>
                            </div>
                        </div>
                        <div class="rpg-character-content">
                            <div class="rpg-character-info">
                `;
                // Render custom fields dynamically
                for (const field of enabledFields) {
                    const rawValue = char[field.name];
                    const fieldValue = extractFieldValue(rawValue);
                    const fieldId = field.name.toLowerCase().replace(/\s+/g, '-');
                    const fieldNameLower = field.name.toLowerCase();
                    // Skip lock icons for thoughts field
                    const showLock = !fieldNameLower.includes('thought');
                    // Add placeholder for empty fields
                    const placeholder = fieldValue ? '' : `data-placeholder="${field.name}"`;
                    const emptyClass = fieldValue ? '' : ' rpg-empty-field';
                    if (showLock) {
                        const lockIconHtml = getLockIconHtml('characters', `${char.name}.${field.name}`);
                        html += `
                                <div class="rpg-character-field rpg-character-${fieldId}" style="position: relative;">
                                    ${lockIconHtml}
                                    <span class="rpg-editable${emptyClass}" contenteditable="true" data-character="${char.name}" data-field="${field.name}" title="Click to edit ${field.name}" ${placeholder}>${fieldValue}</span>
                                </div>
                        `;
                    } else {
                        html += `
                                <div class="rpg-character-field rpg-character-${fieldId} rpg-editable${emptyClass}" contenteditable="true" data-character="${char.name}" data-field="${field.name}" title="Click to edit ${field.name}" ${placeholder}>${fieldValue}</div>
                        `;
                    }
                }
                html += `
                            </div>
                `;
                // Render character stats if enabled (outside rpg-character-info)
                if (enabledCharStats.length > 0) {
                    const lockIconHtml = getLockIconHtml('characters', `${char.name}.stats`);
                    html += `<div class="rpg-character-stats" style="position: relative;">
                        <span class="rpg-section-lock-icon" style="position: absolute; top: 4px; right: 4px; font-size: 1rem; z-index: 10; opacity: 0.7; pointer-events: auto;">${lockIconHtml}</span>
                        <div class="rpg-character-stats-inner">`;
                    for (const stat of enabledCharStats) {
                        const statValue = char[stat.name] || 0;
                        const statColor = getStatColor(
                            statValue,
                            extensionSettings.statBarColorLow,
                            extensionSettings.statBarColorHigh,
                            extensionSettings.statBarColorLowOpacity ?? 100,
                            extensionSettings.statBarColorHighOpacity ?? 100
                        );
                        html += `
                                <div class="rpg-character-stat">
                                    <span class="rpg-stat-name">${stat.name}: </span><span class="rpg-editable" contenteditable="true" data-character="${char.name}" data-field="${stat.name}" style="color: ${statColor}" title="Click to edit ${stat.name}">${statValue}%</span>
                                </div>
                        `;
                    }
                    html += `</div></div>`;
                }
                html += `
                        </div>
                    </div>
                `;
                // ‚îÄ‚îÄ BACK FACE (read-only detail sheet) ‚îÄ‚îÄ
                const thoughtsContent = char.ThoughtsContent || '';
                const relationshipText = char.Relationship || '';
                html += `
                    <div class="rpg-card-back">
                        <div class="rpg-card-back-header">
                            <span class="rpg-card-back-emoji">${char.emoji}</span>
                            <span class="rpg-card-back-name">${char.name}</span>
                            <span class="rpg-card-back-flip-hint"><i class="fa-solid fa-rotate-left"></i></span>
                        </div>
                        <div class="rpg-card-back-body">
                `;
                // Thoughts section
                if (thoughtsContent) {
                    html += `
                            <div class="rpg-card-back-section rpg-card-back-thoughts">
                                <span class="rpg-card-back-label">Thoughts</span>
                                <span class="rpg-card-back-value">${thoughtsContent}</span>
                            </div>
                    `;
                }
                // Relationship section
                if (hasRelationshipEnabled) {
                    html += `
                            <div class="rpg-card-back-section">
                                <span class="rpg-card-back-label">Relationship</span>
                                <span class="rpg-card-back-value${relationshipText ? '' : ' rpg-card-back-empty'}">${relationshipText || 'Unknown'}</span>
                            </div>
                    `;
                }
                // All custom fields with labels
                for (const field of enabledFields) {
                    const rawVal = char[field.name];
                    const val = extractFieldValue(rawVal);
                    html += `
                            <div class="rpg-card-back-section">
                                <span class="rpg-card-back-label">${field.name}</span>
                                <span class="rpg-card-back-value${val ? '' : ' rpg-card-back-empty'}">${val || 'Not set'}</span>
                            </div>
                    `;
                }
                // Stats with visual bars
                if (enabledCharStats.length > 0) {
                    html += `<div class="rpg-card-back-stats">`;
                    for (const stat of enabledCharStats) {
                        const sv = char[stat.name] || 0;
                        const sc = getStatColor(
                            sv,
                            extensionSettings.statBarColorLow,
                            extensionSettings.statBarColorHigh,
                            extensionSettings.statBarColorLowOpacity ?? 100,
                            extensionSettings.statBarColorHighOpacity ?? 100
                        );
                        html += `
                                <div class="rpg-card-back-stat">
                                    <span class="rpg-card-back-stat-name">${stat.name}</span>
                                    <div class="rpg-card-back-stat-bar">
                                        <div class="rpg-card-back-stat-fill" style="width: ${sv}%; background: ${sc};"></div>
                                    </div>
                                    <span class="rpg-card-back-stat-val">${sv}%</span>
                                </div>
                        `;
                    }
                    html += `</div>`;
                }
                html += `
                        </div>
                    </div>
                    </div>
                    </div>
                `;
                debugLog(`[RPG Thoughts] ‚úì Successfully built HTML for ${char.name}`);
            } catch (charError) {
                debugLog(`[RPG Thoughts] ‚úó ERROR building HTML for ${char.name}:`, charError.message);
                debugLog('[RPG Thoughts] Error stack:', charError.stack);
                // Continue with next character instead of crashing
            }
        }
        debugLog('[RPG Thoughts] Finished building all character cards');
        // Add "Add Character" button if data exists (inside rpg-thoughts-content)
        if (presentCharacters.length > 0) {
            html += `
                <button class="rpg-add-character-btn" title="Add a new character">
                    <i class="fa-solid fa-plus"></i> Add Character
                </button>
            `;
        }
        html += '</div>';
    }
    $thoughtsContainer.html(html);
    debugLog('[RPG Thoughts] ‚úì HTML rendered to container');
    debugLog('[RPG Thoughts] =======================================================');
    // NOTE: Event handlers are registered ONCE via initThoughtsEventDelegation()
    // using delegated events on $thoughtsContainer. No need to re-attach on each render.
    // Remove updating class after animation
    if (extensionSettings.enableAnimations) {
        setTimeout(() => $thoughtsContainer.removeClass('rpg-content-updating'), 600);
    }
    // Restore scroll position after re-render
    if (preserveScroll) {
        const $content = $thoughtsContainer.find('.rpg-thoughts-content');
        if ($content.length) {
            $content[0].scrollTop = savedContentScroll;
        }
    }
    // Update chat overlay if enabled
    if (extensionSettings.showThoughtsInChat) {
        updateChatThoughts();
    }
}
/**
 * Removes a character from Present Characters data and re-renders.
 *
 * @param {string} characterName - Name of the character to remove
 */
export function removeCharacter(characterName) {
    if (!lastGeneratedData.characterThoughts) {
        return;
    }
    // Check if data is in JSON format
    let isJSON = false;
    let parsedData = null;
    try {
        parsedData = typeof lastGeneratedData.characterThoughts === 'string'
            ? JSON.parse(lastGeneratedData.characterThoughts)
            : lastGeneratedData.characterThoughts;
        if (Array.isArray(parsedData) || (parsedData && parsedData.characters)) {
            isJSON = true;
        }
    } catch (e) {
        // Not JSON, treat as text format
    }
    if (isJSON) {
        // JSON format - remove character from array
        let characters = Array.isArray(parsedData) ? parsedData : parsedData.characters;
        characters = characters.filter(char => char.name !== characterName);
        if (Array.isArray(parsedData)) {
            parsedData = characters;
        } else {
            parsedData.characters = characters;
        }
        const updatedJSON = JSON.stringify(parsedData, null, 2);
        lastGeneratedData.characterThoughts = updatedJSON;
        committedTrackerData.characterThoughts = updatedJSON;
    } else {
        // Text format - remove character block
        const lines = lastGeneratedData.characterThoughts.split('\n');
        const dividerIndex = lines.findIndex(line => line.includes('---'));
        if (dividerIndex === -1) return;
        // Find the character block to remove
        let startLineIndex = -1;
        let endLineIndex = -1;
        for (let i = dividerIndex + 1; i < lines.length; i++) {
            const line = lines[i].trim();
            // Check if this is the start of the character block
            if (line.startsWith('Name:')) {
                const nameMatch = line.match(/^Name:\s*(.+)/);
                if (nameMatch && nameMatch[1].trim() === characterName) {
                    startLineIndex = i;
                }
            }
            // If we found the start, look for the end
            if (startLineIndex !== -1 && i > startLineIndex) {
                // End of block is either another "Name:" line or end of content
                if (line.startsWith('Name:') || i === lines.length - 1) {
                    endLineIndex = line.startsWith('Name:') ? i - 1 : i;
                    // Remove empty lines at the end of the block
                    while (endLineIndex > startLineIndex && !lines[endLineIndex].trim()) {
                        endLineIndex--;
                    }
                    break;
                }
            }
        }
        // Remove the character block
        if (startLineIndex !== -1 && endLineIndex !== -1) {
            lines.splice(startLineIndex, endLineIndex - startLineIndex + 1);
            // Remove empty lines after removal to keep formatting clean
            let i = startLineIndex;
            while (i < lines.length && !lines[i].trim()) {
                lines.splice(i, 1);
            }
        }
        lastGeneratedData.characterThoughts = lines.join('\n');
        committedTrackerData.characterThoughts = lines.join('\n');
    }
    // Update message swipe data
    const chat = getContext().chat;
    if (chat && chat.length > 0) {
        for (let i = chat.length - 1; i >= 0; i--) {
            const message = chat[i];
            if (!message.is_user) {
                if (message.extra && message.extra.dooms_tracker_swipes) {
                    const swipeId = message.swipe_id || 0;
                    if (message.extra.dooms_tracker_swipes[swipeId]) {
                        message.extra.dooms_tracker_swipes[swipeId].characterThoughts = lastGeneratedData.characterThoughts;
                    }
                }
                break;
            }
        }
    }
    saveChatData();
    // Re-render to show updated character list
    renderThoughts();
}
/**
 * Adds a new blank character to Present Characters data.
 * Creates a character with empty fields based on the tracker template.
 */
export function addNewCharacter() {
    const presentCharsConfig = extensionSettings.trackerConfig?.presentCharacters;
    const enabledFields = presentCharsConfig?.customFields?.filter(f => f && f.enabled && f.name) || [];
    const characterStats = presentCharsConfig?.characterStats;
    const enabledCharStats = characterStats?.enabled && characterStats?.customStats?.filter(s => s && s.enabled && s.name) || [];
    const hasRelationship = presentCharsConfig?.relationshipFields?.length > 0;
    // Check if data is in JSON format
    let isJSON = false;
    let parsedData = null;
    try {
        parsedData = typeof lastGeneratedData.characterThoughts === 'string'
            ? JSON.parse(lastGeneratedData.characterThoughts)
            : lastGeneratedData.characterThoughts;
        if (Array.isArray(parsedData) || (parsedData && parsedData.characters)) {
            isJSON = true;
        }
    } catch (e) {
        // Not JSON, treat as text format
    }
    if (isJSON) {
        // JSON format - add new character object
        const charactersArray = Array.isArray(parsedData) ? parsedData : (parsedData.characters || []);
        const newCharacter = {
            name: 'New Character',
            emoji: 'üë§',
            details: {}
        };
        // Add all enabled custom fields as empty
        for (const field of enabledFields) {
            newCharacter.details[field.name] = '';
        }
        // Add relationship if enabled
        if (hasRelationship) {
            newCharacter.relationship = 'Neutral';
        }
        // Add stats if enabled
        if (enabledCharStats.length > 0) {
            newCharacter.stats = {};
            for (const stat of enabledCharStats) {
                newCharacter.stats[stat.name] = 100;
            }
        }
        charactersArray.push(newCharacter);
        // Save back as JSON string
        lastGeneratedData.characterThoughts = JSON.stringify(
            Array.isArray(parsedData) ? charactersArray : { ...parsedData, characters: charactersArray },
            null,
            2
        );
        committedTrackerData.characterThoughts = lastGeneratedData.characterThoughts;
    } else {
        // Text format - add new character block
        const lines = lastGeneratedData.characterThoughts.split('\n');
        const dividerIndex = lines.findIndex(line => line.includes('---'));
        if (dividerIndex >= 0) {
            const newCharacterLines = ['- New Character'];
            // Add custom detail fields as standalone lines
            for (const customField of enabledFields) {
                newCharacterLines.push(`  ${customField.name}: `);
            }
            // Add Relationship field if enabled
            if (hasRelationship) {
                newCharacterLines.push(`  Relationship: Neutral`);
            }
            // Add Stats if enabled
            if (enabledCharStats.length > 0) {
                const statsParts = enabledCharStats.map(s => `${s.name}: 100%`);
                newCharacterLines.push(`  Stats: ${statsParts.join(' | ')}`);
            }
            // Find the last character and add after it, or after divider if no characters
            let insertIndex = dividerIndex + 1;
            for (let i = lines.length - 1; i > dividerIndex; i--) {
                if (lines[i].trim().startsWith('- ')) {
                    // Find the end of this character block
                    insertIndex = i + 1;
                    while (insertIndex < lines.length && lines[insertIndex].trim() && !lines[insertIndex].trim().startsWith('- ')) {
                        insertIndex++;
                    }
                    break;
                }
            }
            lines.splice(insertIndex, 0, ...newCharacterLines);
            lastGeneratedData.characterThoughts = lines.join('\n');
            committedTrackerData.characterThoughts = lines.join('\n');
        }
    }
    // Update message swipe data
    const chat = getContext().chat;
    if (chat && chat.length > 0) {
        for (let i = chat.length - 1; i >= 0; i--) {
            const message = chat[i];
            if (!message.is_user) {
                if (message.extra && message.extra.dooms_tracker_swipes) {
                    const swipeId = message.swipe_id || 0;
                    if (message.extra.dooms_tracker_swipes[swipeId]) {
                        message.extra.dooms_tracker_swipes[swipeId].characterThoughts = lastGeneratedData.characterThoughts;
                    }
                }
                break;
            }
        }
    }
    saveChatData();
    // Re-render to show new character
    renderThoughts();
}
/**
 * Updates a specific character field in Present Characters data and re-renders.
 * Works with the new multi-line format.
 *
 * @param {string} characterName - Name of the character to update
 * @param {string} field - Field to update (emoji, name, custom field name, Relationship, stat name)
 * @param {string} value - New value for the field
 */
export function updateCharacterField(characterName, field, value) {
    // Initialize if it doesn't exist
    if (!lastGeneratedData.characterThoughts) {
        lastGeneratedData.characterThoughts = 'Present Characters\n---\n';
    }
    const presentCharsConfig = extensionSettings.trackerConfig?.presentCharacters;
    const enabledFields = presentCharsConfig?.customFields?.filter(f => f && f.enabled && f.name) || [];
    const characterStats = presentCharsConfig?.characterStats;
    const enabledCharStats = characterStats?.enabled && characterStats?.customStats?.filter(s => s && s.enabled && s.name) || [];
    // Get relationship emoji mappings from config
    const relationshipEmojis = presentCharsConfig?.relationshipEmojis || {
        'Enemy': '‚öîÔ∏è',
        'Neutral': '‚öñÔ∏è',
        'Friend': '‚≠ê',
        'Lover': '‚ù§Ô∏è'
    };
    // Create reverse mapping (emoji ‚Üí name)
    const emojiToRelationship = {};
    for (const [name, emoji] of Object.entries(relationshipEmojis)) {
        emojiToRelationship[emoji] = name;
    }
    // Check if data is in JSON format
    let isJSON = false;
    let parsedData = null;
    try {
        parsedData = typeof lastGeneratedData.characterThoughts === 'string'
            ? JSON.parse(lastGeneratedData.characterThoughts)
            : lastGeneratedData.characterThoughts;
        if (Array.isArray(parsedData) || (parsedData && parsedData.characters)) {
            isJSON = true;
        }
    } catch (e) {
        // Not JSON, continue with text format
    }
    // Handle JSON format
    if (isJSON) {
        const charactersArray = Array.isArray(parsedData) ? parsedData : (parsedData.characters || []);
        const charIndex = charactersArray.findIndex(c =>
            c.name && c.name.toLowerCase() === characterName.toLowerCase()
        );
        if (charIndex !== -1) {
            const char = charactersArray[charIndex];
            // Update the appropriate field
            if (field === 'name') {
                char.name = value;
            } else if (field === 'emoji') {
                char.emoji = value;
            } else if (field === 'Relationship') {
                // Store relationship in the correct nested format
                // Remove old flat format if it exists
                if (char.Relationship) {
                    delete char.Relationship;
                }
                // First check if it's an emoji ‚Üí convert to text
                let relationshipValue;
                if (emojiToRelationship[value]) {
                    relationshipValue = emojiToRelationship[value];
                } else {
                    // It's text - find matching relationship name (case-insensitive)
                    const matchingRelationship = Object.keys(relationshipEmojis).find(
                        name => name.toLowerCase() === value.toLowerCase()
                    );
                    relationshipValue = matchingRelationship || value;
                }
                // Store in the correct nested format
                char.relationship = { status: relationshipValue };
            } else if (field.toLowerCase() === 'thoughts' || field === (presentCharsConfig?.thoughts?.name || 'Thoughts')) {
                if (!char.thoughts) char.thoughts = {};
                char.thoughts.content = value;
            } else {
                // Check if it's a character stat
                const isStatField = enabledCharStats.findIndex(s => s.name === field) !== -1;
                if (isStatField) {
                    let numValue = parseInt(value.replace('%', '').trim());
                    if (isNaN(numValue)) numValue = 0;
                    numValue = Math.max(0, Math.min(100, numValue));
                    // Handle both array format (from LLM) and object format
                    if (Array.isArray(char.stats)) {
                        // Array format: [{name: "Health", value: 80}]
                        const statIndex = char.stats.findIndex(s => s.name === field);
                        if (statIndex !== -1) {
                            char.stats[statIndex].value = numValue;
                        } else {
                            // Stat not found in array - add it
                            char.stats.push({ name: field, value: numValue });
                        }
                    } else {
                        // Object format: {Health: 80} or undefined
                        if (!char.stats) char.stats = {};
                        char.stats[field] = numValue;
                    }
                } else {
                    // It's a custom detail field - store in details object
                    if (!char.details) char.details = {};
                    char.details[field] = value;
                    // Clean up snake_case version if it exists (from AI generation)
                    const fieldKey = toSnakeCase(field);
                    if (fieldKey !== field && char.details[fieldKey] !== undefined) {
                        delete char.details[fieldKey];
                    }
                    // Clean up old root-level field if it exists (from v2 format)
                    if (char[field] !== undefined && field !== 'name' && field !== 'emoji') {
                        delete char[field];
                    }
                    if (char[fieldKey] !== undefined && fieldKey !== 'name' && fieldKey !== 'emoji') {
                        delete char[fieldKey];
                    }
                }
            }
            // Clean up ALL duplicate snake_case fields in details (not just the edited field)
            // This prevents duplicates from AI-generated data
            if (char.details) {
                for (const customField of enabledFields) {
                    const fieldName = customField.name;
                    const snakeCaseKey = toSnakeCase(fieldName);
                    // If both versions exist, keep the properly-cased one and remove snake_case
                    if (snakeCaseKey !== fieldName &&
                        char.details[fieldName] !== undefined &&
                        char.details[snakeCaseKey] !== undefined) {
                        delete char.details[snakeCaseKey];
                    }
                }
            }
        }
        // Save back to lastGeneratedData as JSON string (consistent with infoBox and userStats)
        lastGeneratedData.characterThoughts = JSON.stringify(Array.isArray(parsedData) ? charactersArray : { ...parsedData, characters: charactersArray }, null, 2);
        committedTrackerData.characterThoughts = lastGeneratedData.characterThoughts;
        // Update in chat metadata
        const chat = getContext().chat;
        if (chat && chat.length > 0) {
            for (let i = chat.length - 1; i >= 0; i--) {
                const message = chat[i];
                if (!message.is_user) {
                    if (message.extra && message.extra.dooms_tracker_swipes) {
                        const swipeId = message.swipe_id || 0;
                        if (message.extra.dooms_tracker_swipes[swipeId]) {
                            message.extra.dooms_tracker_swipes[swipeId].characterThoughts = lastGeneratedData.characterThoughts;
                        }
                    }
                    break;
                }
            }
        }
        saveChatData();
        // Re-render the thoughts panel to show updated value (preserve scroll position)
        renderThoughts({ preserveScroll: true });
        // Update chat thought overlays if editing thoughts
        const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
        const isEditingThoughts = field === thoughtsFieldName || field === 'thoughts';
        if (isEditingThoughts && extensionSettings.showThoughtsInChat) {
            updateChatThoughts();
        }
        return; // Exit early for JSON format
    }
    // Continue with text format handling below
    const lines = lastGeneratedData.characterThoughts.split('\n');
    let characterFound = false;
    let inTargetCharacter = false;
    let characterStartIndex = -1;
    let characterEndIndex = -1;
    // Find the character block
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('- ')) {
            const name = line.substring(2).trim();
            if (name.toLowerCase() === characterName.toLowerCase()) {
                characterFound = true;
                inTargetCharacter = true;
                characterStartIndex = i;
            } else if (inTargetCharacter) {
                characterEndIndex = i;
                break;
            }
        }
    }
    if (characterFound && characterEndIndex === -1) {
        characterEndIndex = lines.length;
    }
    if (characterFound) {
        // Check if we're updating a character stat
        const isStatField = enabledCharStats.findIndex(s => s.name === field) !== -1;
        let statsLineExists = false;
        let statsLineIndex = -1;
        // Get the configured thoughts field name
        const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
        const isThoughtsField = field.toLowerCase() === 'thoughts' || field === thoughtsFieldName;
        // Track if field was found and updated
        let fieldUpdated = false;
        // First pass: check if Stats line exists and update other fields
        for (let i = characterStartIndex; i < characterEndIndex; i++) {
            const line = lines[i].trim();
            if (line.startsWith('Stats:')) {
                statsLineExists = true;
                statsLineIndex = i;
                continue; // Skip to next line
            }
            // Check for name update
            if (field === 'name' && line.startsWith('- ')) {
                lines[i] = `- ${value}`;
                fieldUpdated = true;
                continue;
            }
            // Check for Relationship field
            if (field === 'Relationship' && line.startsWith('Relationship:')) {
                const emojiToRelationship = { '‚öîÔ∏è': 'Enemy', '‚öñÔ∏è': 'Neutral', '‚≠ê': 'Friend', '‚ù§Ô∏è': 'Lover' };
                const relationshipValue = emojiToRelationship[value] || value;
                lines[i] = `Relationship: ${relationshipValue}`;
                fieldUpdated = true;
                continue;
            }
            // Check for Thoughts field
            if (isThoughtsField && line.startsWith(thoughtsFieldName + ':')) {
                lines[i] = `  ${thoughtsFieldName}: ${value}`;
                fieldUpdated = true;
                continue;
            }
            // Check for v3 text format standalone field lines (e.g., "Appearance: ...", "Demeanor: ...")
            if (line.startsWith(field + ':')) {
                lines[i] = `  ${field}: ${value}`;
                fieldUpdated = true;
                // Don't break - update ALL instances of this field (in case of duplicates from previous bugs)
            }
        }
        // Handle stat updates
        if (isStatField) {
            // Clean the value: remove % if present, parse as integer, clamp 0-100
            let cleanValue = value.replace('%', '').trim();
            let numValue = parseInt(cleanValue);
            if (isNaN(numValue)) {
                numValue = 0;
            }
            numValue = Math.max(0, Math.min(100, numValue));
            if (statsLineExists) {
                // Update existing Stats line
                const line = lines[statsLineIndex];
                const statsContent = line.substring(line.indexOf(':') + 1).trim();
                const statParts = statsContent.split('|').map(p => p.trim());
                let statFound = false;
                for (let j = 0; j < statParts.length; j++) {
                    if (statParts[j].startsWith(field + ':')) {
                        statParts[j] = `${field}: ${numValue}%`;
                        statFound = true;
                        break;
                    }
                }
                // If stat wasn't found in existing parts, add it
                if (!statFound) {
                    statParts.push(`${field}: ${numValue}%`);
                }
                lines[statsLineIndex] = `Stats: ${statParts.join(' | ')}`;
            } else {
                // Create new Stats line with all enabled stats (defaulting to 0% except the one being edited)
                const statsParts = enabledCharStats.map(s => {
                    if (s.name === field) {
                        return `${s.name}: ${numValue}%`;
                    }
                    return `${s.name}: 0%`;
                });
                const newStatsLine = `Stats: ${statsParts.join(' | ')}`;
                // Insert before Thoughts line or at end of character block
                let insertIndex = characterEndIndex;
                for (let i = characterStartIndex; i < characterEndIndex; i++) {
                    const line = lines[i].trim();
                    const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
                    if (line.startsWith(thoughtsFieldName + ':')) {
                        insertIndex = i;
                        break;
                    }
                }
                lines.splice(insertIndex, 0, newStatsLine);
                characterEndIndex++; // Adjust end index since we inserted a line
            }
        }
    } else {
        // Create new character block (v3 text format only)
        const dividerIndex = lines.findIndex(line => line.includes('---'));
        if (dividerIndex >= 0) {
            const newCharacterLines = [`- ${characterName}`];
            // Add custom detail fields as standalone lines
            for (const customField of enabledFields) {
                if (field === customField.name) {
                    newCharacterLines.push(`  ${customField.name}: ${value}`);
                } else {
                    newCharacterLines.push(`  ${customField.name}: `);
                }
            }
            // Add Relationship field if enabled
            if (presentCharsConfig?.relationshipFields?.length > 0) {
                const emojiToRelationship = { '‚öîÔ∏è': 'Enemy', '‚öñÔ∏è': 'Neutral', '‚≠ê': 'Friend', '‚ù§Ô∏è': 'Lover' };
                const relationshipValue = field === 'Relationship' ? (emojiToRelationship[value] || value) : 'Neutral';
                newCharacterLines.push(`  Relationship: ${relationshipValue}`);
            }
            // Add Stats if enabled
            if (enabledCharStats.length > 0) {
                const statsParts = enabledCharStats.map(s => {
                    if (field === s.name) {
                        // Clean the value: remove % if present, parse as integer, clamp 0-100
                        let cleanValue = value.replace('%', '').trim();
                        let numValue = parseInt(cleanValue);
                        if (isNaN(numValue)) {
                            numValue = 0;
                        }
                        numValue = Math.max(0, Math.min(100, numValue));
                        return `${s.name}: ${numValue}%`;
                    }
                    return `${s.name}: 0%`;
                });
                newCharacterLines.push(`  Stats: ${statsParts.join(' | ')}`);
            }
            lines.splice(dividerIndex + 1, 0, ...newCharacterLines);
        }
    }
    lastGeneratedData.characterThoughts = lines.join('\n');
    committedTrackerData.characterThoughts = lines.join('\n');
    const chat = getContext().chat;
    if (chat && chat.length > 0) {
        for (let i = chat.length - 1; i >= 0; i--) {
            const message = chat[i];
            if (!message.is_user) {
                if (message.extra && message.extra.dooms_tracker_swipes) {
                    const swipeId = message.swipe_id || 0;
                    if (message.extra.dooms_tracker_swipes[swipeId]) {
                        message.extra.dooms_tracker_swipes[swipeId].characterThoughts = lines.join('\n');
                    }
                }
                break;
            }
        }
    }
    saveChatData();
    // Don't re-render to avoid overwriting user edits while they're still editing
    // The changes are already saved to lastGeneratedData and committedTrackerData
    // Re-rendering would cause the display to reset and lose focus
    // Only update chat thought overlays if editing thoughts field
    const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
    const isEditingThoughts = field === thoughtsFieldName || field === 'thoughts';
    if (isEditingThoughts && extensionSettings.showThoughtsInChat) {
        // Update chat thought bubbles when thoughts are edited
        updateChatThoughts();
    }
    // Note: Don't call renderThoughts() here - it would overwrite the user's edits
}
/**
 * Renders only the sidebar thoughts panel without updating chat bubbles
 */
function renderThoughtsSidebarOnly() {
    if (!extensionSettings.showCharacterThoughts || !$thoughtsContainer) {
        return;
    }
    // This is a simplified version that only updates the sidebar
    // Copy the rendering logic from renderThoughts but skip the updateChatThoughts call
    const thoughtsData = lastGeneratedData.characterThoughts || committedTrackerData.characterThoughts;
    if (!thoughtsData) {
        $thoughtsContainer.html('<div class="rpg-inventory-empty">No character data generated yet</div>');
        return;
    }
    // Re-render sidebar content (this would be the full logic from renderThoughts)
    // For now, just call renderThoughts but set a flag
    const originalShowInChat = extensionSettings.showThoughtsInChat;
    extensionSettings.showThoughtsInChat = false;
    renderThoughts();
    extensionSettings.showThoughtsInChat = originalShowInChat;
}
/**
 * Updates or removes thought overlays in the chat.
 * Creates floating thought bubbles positioned near character avatars.
 */
export function updateChatThoughts() {
    const _debug = extensionSettings.debugMode;
    if (_debug) console.log('[Dooms Tracker] ======== updateChatThoughts called ========');
    // Remove old floating thought panel/icon (legacy cleanup)
    $('#rpg-thought-panel').remove();
    $('#rpg-thought-icon').remove();
    $('#chat').off('scroll.thoughtPanel');
    $(window).off('resize.thoughtPanel');
    $(document).off('click.thoughtPanel');
    // Remove any existing inline thought dropdowns from previous renders
    $('.dooms-inline-thought').remove();
    // If extension is disabled, thoughts in chat are disabled, or no thoughts, just return
    if (!extensionSettings.enabled || !extensionSettings.showThoughtsInChat || !lastGeneratedData.characterThoughts) {
        if (_debug) console.log('[Dooms Tracker] Inline thoughts skipped - enabled:', extensionSettings.enabled, 'showThoughtsInChat:', extensionSettings.showThoughtsInChat, 'hasData:', !!lastGeneratedData.characterThoughts);
        return;
    }
    // Parse the Present Characters data to get thoughts
    const thoughtsArray = parseThoughtsArray();
    if (_debug) {
        console.log('[Dooms Tracker] Parsed thoughts array:', thoughtsArray.length, 'thoughts');
        thoughtsArray.forEach(t => console.log('[Dooms Tracker]   -', t.name, ':', t.thought?.substring(0, 50) + '...'));
    }
    // If no thoughts parsed, return
    if (thoughtsArray.length === 0) {
        if (_debug) console.log('[Dooms Tracker] No thoughts parsed, returning');
        return;
    }
    // Find the most recent non-user message
    const $messages = $('#chat .mes');
    let $targetMessage = null;
    for (let i = $messages.length - 1; i >= 0; i--) {
        const $message = $messages.eq(i);
        if ($message.attr('is_user') !== 'true') {
            $targetMessage = $message;
            break;
        }
    }
    if (!$targetMessage) {
        if (_debug) console.log('[Dooms Tracker] No target message found for inline thoughts');
        return;
    }
    if (_debug) console.log('[Dooms Tracker] Target message found, inserting inline thought dropdowns...');
    // Insert inline thought dropdowns into the message
    insertInlineThoughts($targetMessage, thoughtsArray);
}
/**
 * Parses character thoughts from lastGeneratedData into a simple array.
 * @returns {Array<{name: string, emoji: string, thought: string}>}
 */
function parseThoughtsArray() {
    let thoughtsArray = [];
    const thoughtsConfig = extensionSettings.trackerConfig?.presentCharacters?.thoughts;
    const thoughtsLabel = thoughtsConfig?.name || 'Thoughts';
    // Try JSON format first
    try {
        const parsed = typeof lastGeneratedData.characterThoughts === 'string'
            ? JSON.parse(lastGeneratedData.characterThoughts)
            : lastGeneratedData.characterThoughts;
        const charactersArray = Array.isArray(parsed) ? parsed : (parsed.characters || []);
        if (charactersArray.length > 0) {
            const offScene = /\b(not\s+(currently\s+)?(in|at|present|in\s+the)\s+(the\s+)?(scene|area|room|location|vicinity))\b|\b(off[\s-]?scene)\b|\b(not\s+present)\b|\b(absent)\b|\b(away\s+from\s+(the\s+)?scene)\b/i;
            thoughtsArray = charactersArray
                .filter(char => char.thoughts && char.thoughts.content && !offScene.test(char.thoughts.content))
                .map(char => ({
                    name: (char.name || ''),
                    emoji: char.emoji || 'üë§',
                    thought: char.thoughts.content
                }));
            if (extensionSettings.debugMode) console.log('[Dooms Tracker] Parsed JSON format thoughts:', thoughtsArray.length);
        }
    } catch (e) {
        if (extensionSettings.debugMode) console.log('[Dooms Tracker] Not JSON format, falling back to text parsing');
    }
    // If JSON parsing failed or returned empty, try text format
    if (thoughtsArray.length === 0 && lastGeneratedData.characterThoughts) {
        const lines = lastGeneratedData.characterThoughts.split('\n');
        let currentCharName = null;
        let currentCharEmoji = null;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line ||
                line.includes('Present Characters') ||
                line.includes('---') ||
                line.startsWith('```') ||
                line.trim() === '- ‚Ä¶' ||
                line.includes('(Repeat the format')) {
                continue;
            }
            if (line.startsWith('- ')) {
                const name = line.substring(2).trim();
                if (name && name.toLowerCase() !== 'unavailable') {
                    currentCharName = name;
                    currentCharEmoji = null;
                } else {
                    currentCharName = null;
                    currentCharEmoji = null;
                }
            } else if (line.startsWith('Details:') && currentCharName) {
                const detailsContent = line.substring(line.indexOf(':') + 1).trim();
                const parts = detailsContent.split('|').map(p => p.trim());
                if (parts.length > 0) {
                    currentCharEmoji = parts[0];
                }
            } else if (line.startsWith(thoughtsLabel + ':') && currentCharName && currentCharEmoji) {
                const thoughtContent = line.substring(thoughtsLabel.length + 1).trim();
                if (thoughtContent) {
                    thoughtsArray.push({
                        name: currentCharName,
                        emoji: currentCharEmoji,
                        thought: thoughtContent
                    });
                }
            }
        }
    }
    return thoughtsArray;
}
/**
 * Inserts inline collapsible thought dropdowns into a chat message.
 * For each character with a thought, finds their dialogue in the message
 * and appends a <details> dropdown right after it.
 *
 * @param {jQuery} $message - The message element to insert thoughts into
 * @param {Array<{name: string, emoji: string, thought: string}>} thoughtsArray
 */
function insertInlineThoughts($message, thoughtsArray) {
    const _debug = extensionSettings.debugMode;
    const $mesText = $message.find('.mes_text');
    if (!$mesText.length) {
        if (_debug) console.log('[Dooms Tracker] No .mes_text found in target message');
        return;
    }
    if (_debug) console.log('[Dooms Tracker] .mes_text found, HTML length:', $mesText.html().length);
    // Build a map of character name (lowercase) -> thought data
    const thoughtsMap = {};
    for (const t of thoughtsArray) {
        thoughtsMap[t.name.toLowerCase()] = t;
    }
    if (_debug) console.log('[Dooms Tracker] Thoughts map keys:', Object.keys(thoughtsMap));
    // Append all character thought dropdowns at the bottom of the message
    let insertedCount = 0;
    for (const [nameLower, thoughtData] of Object.entries(thoughtsMap)) {
        const $dropdown = createThoughtDropdown(thoughtData);
        $mesText.append($dropdown);
        insertedCount++;
    }
    if (_debug) console.log('[Dooms Tracker] Inserted', insertedCount, 'inline thought dropdowns at end of message');
}
/**
 * Creates a single inline thought dropdown element.
 * @param {{name: string, emoji: string, thought: string}} thoughtData
 * @returns {jQuery} The dropdown element
 */
function createThoughtDropdown(thoughtData) {
    const $dropdown = $(`
        <details class="dooms-inline-thought" data-character="${thoughtData.name.toLowerCase()}">
            <summary class="dooms-inline-thought-summary">
                <span class="dooms-thought-icon">üí≠</span>
                <span class="dooms-thought-name">${thoughtData.emoji} ${thoughtData.name}'s thoughts</span>
                <button class="dooms-thought-tts" title="Read thoughts aloud"><i class="fa-solid fa-bullhorn"></i></button>
            </summary>
            <div class="dooms-inline-thought-content">
                ${thoughtData.thought}
            </div>
        </details>
    `);
    return $dropdown;
}
// ===== GLOBAL DRAGGING SETUP FOR THOUGHT ICON (MOBILE ONLY) =====
// These variables and handlers are set up once, outside createThoughtPanel
let isDragging = false;
let touchMoved = false;
let dragStartTime = 0;
let dragStartX = 0;
let dragStartY = 0;
let iconStartX = 0;
let iconStartY = 0;
const DRAG_THRESHOLD = 10;
const LONG_PRESS_DURATION = 200;
let rafId = null;
let pendingX = null;
let pendingY = null;
let thoughtIconDragHandlersInitialized = false;
let justFinishedDragging = false; // Flag to block clicks immediately after drag
function updateIconDragPosition() {
    if (pendingX !== null && pendingY !== null) {
        $('#rpg-thought-icon').css({
            left: pendingX + 'px',
            top: pendingY + 'px',
            right: 'auto',
            bottom: 'auto'
        });
        pendingX = null;
        pendingY = null;
    }
    rafId = null;
}
function initThoughtIconDragHandlers() {
    if (thoughtIconDragHandlersInitialized) return;
    thoughtIconDragHandlersInitialized = true;
}
// Function to attach drag handlers to a specific icon element
function attachDragHandlersToIcon($icon) {
    // Remove any existing handlers
    $icon.off('.thoughtIconDrag');
    // Test: add a simple click handler to verify events work
    $icon.on('click.thoughtIconDrag', function(e) {
        // Check global flag set immediately after drag completes
        if (justFinishedDragging) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }
    });
    // Touch drag support - mobile only
    $icon.on('touchstart.thoughtIconDrag', function(e) {
        if (window.innerWidth > 1000) return;
        touchMoved = false;
        dragStartTime = Date.now();
        const touch = e.originalEvent.touches[0];
        dragStartX = touch.clientX;
        dragStartY = touch.clientY;
        const offset = $(this).offset();
        iconStartX = offset.left;
        iconStartY = offset.top;
        isDragging = false;
    });
    $icon.on('touchmove.thoughtIconDrag', function(e) {
        if (window.innerWidth > 1000) return;
        if (!touchMoved) {
        }
        touchMoved = true;
        const touch = e.originalEvent.touches[0];
        const deltaX = touch.clientX - dragStartX;
        const deltaY = touch.clientY - dragStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const timeSinceStart = Date.now() - dragStartTime;
        if (!isDragging && (timeSinceStart > LONG_PRESS_DURATION || distance > DRAG_THRESHOLD)) {
            isDragging = true;
            $(this).addClass('dragging');
        }
        if (isDragging) {
            e.preventDefault();
            let newX = iconStartX + deltaX;
            let newY = iconStartY + deltaY;
            const iconWidth = $(this).outerWidth();
            const iconHeight = $(this).outerHeight();
            const minX = 10;
            const maxX = window.innerWidth - iconWidth - 10;
            const minY = 10;
            const maxY = window.innerHeight - iconHeight - 10;
            newX = Math.max(minX, Math.min(maxX, newX));
            newY = Math.max(minY, Math.min(maxY, newY));
            pendingX = newX;
            pendingY = newY;
            if (!rafId) {
                rafId = requestAnimationFrame(updateIconDragPosition);
            }
        }
    });
    $icon.on('touchend.thoughtIconDrag', function(e) {
        if (isDragging) {
            const offset = $(this).offset();
            const newPosition = {
                left: offset.left + 'px',
                top: offset.top + 'px'
            };
            extensionSettings.thoughtIconPosition = newPosition;
            saveSettings();
            setTimeout(() => {
                const $currentIcon = $('#rpg-thought-icon');
                if ($currentIcon.length) {
                    constrainIconToViewport($currentIcon);
                }
            }, 10);
            setTimeout(() => {
                $(this).removeClass('dragging');
            }, 50);
            isDragging = false;
            $(this).data('just-dragged', true);
            setTimeout(() => {
                $(this).data('just-dragged', false);
            }, 300);
            e.preventDefault();
            e.stopPropagation();
        } else if (!touchMoved) {
            const $panel = $('#rpg-thought-panel');
            const iconOffset = $(this).offset();
            if (iconOffset) {
                $panel.css({
                    top: iconOffset.top + 'px',
                    left: iconOffset.left + 'px',
                    display: 'none'
                });
            }
            $(this).addClass('rpg-hidden');
            $panel.fadeIn(200);
        } else {
        }
    });
    // Mouse drag support - mobile only
    let mouseDown = false;
    $icon.on('mousedown.thoughtIconDrag', function(e) {
        if (window.innerWidth > 1000) return;
        e.preventDefault();
        mouseDown = true;
        touchMoved = false;
        dragStartTime = Date.now();
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        const offset = $(this).offset();
        iconStartX = offset.left;
        iconStartY = offset.top;
        isDragging = false;
    });
    $(document).on('mousemove.thoughtIconDrag', function(e) {
        if (!mouseDown || window.innerWidth > 1000) return;
        if (!touchMoved) {
        }
        touchMoved = true;
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const timeSinceStart = Date.now() - dragStartTime;
        if (!isDragging && (timeSinceStart > LONG_PRESS_DURATION || distance > DRAG_THRESHOLD)) {
            isDragging = true;
            $('#rpg-thought-icon').addClass('dragging');
        }
        if (isDragging) {
            e.preventDefault();
            let newX = iconStartX + deltaX;
            let newY = iconStartY + deltaY;
            const $currentIcon = $('#rpg-thought-icon');
            const iconWidth = $currentIcon.outerWidth();
            const iconHeight = $currentIcon.outerHeight();
            const minX = 10;
            const maxX = window.innerWidth - iconWidth - 10;
            const minY = 10;
            const maxY = window.innerHeight - iconHeight - 10;
            newX = Math.max(minX, Math.min(maxX, newX));
            newY = Math.max(minY, Math.min(maxY, newY));
            pendingX = newX;
            pendingY = newY;
            if (!rafId) {
                rafId = requestAnimationFrame(updateIconDragPosition);
            }
        }
    });
    $(document).on('mouseup.thoughtIconDrag', function(e) {
        if (!mouseDown) return;
        mouseDown = false;
        if (isDragging) {
            // Set global flag IMMEDIATELY to block click event
            justFinishedDragging = true;
            setTimeout(() => {
                justFinishedDragging = false;
            }, 300);
            const $currentIcon = $('#rpg-thought-icon');
            // Remove dragging class immediately to restore transitions and cursor
            $currentIcon.removeClass('dragging');
            const offset = $currentIcon.offset();
            const newPosition = {
                left: offset.left + 'px',
                top: offset.top + 'px'
            };
            extensionSettings.thoughtIconPosition = newPosition;
            saveSettings();
            setTimeout(() => {
                if ($currentIcon.length) {
                    constrainIconToViewport($currentIcon);
                }
            }, 10);
            isDragging = false;
            // Prevent default and stop all propagation
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }
        // If not dragging but touchMoved, do nothing (small drag below threshold)
    });
}
function constrainIconToViewport($icon) {
    if (!extensionSettings.thoughtIconPosition) return;
    const offset = $icon.offset();
    if (!offset) return;
    let currentX = offset.left;
    let currentY = offset.top;
    const iconWidth = $icon.outerWidth();
    const iconHeight = $icon.outerHeight();
    const minX = 10;
    const maxX = window.innerWidth - iconWidth - 10;
    const minY = 10;
    const maxY = window.innerHeight - iconHeight - 10;
    let newX = Math.max(minX, Math.min(maxX, currentX));
    let newY = Math.max(minY, Math.min(maxY, currentY));
    if (newX !== currentX || newY !== currentY) {
        $icon.css({
            left: newX + 'px',
            top: newY + 'px',
            right: 'auto',
            bottom: 'auto'
        });
        extensionSettings.thoughtIconPosition = {
            left: newX + 'px',
            top: newY + 'px'
        };
        saveSettings();
    }
}
/**
 * Creates or updates the floating thought panel positioned next to the character's avatar.
 * Handles responsive positioning for left/right panel modes and mobile viewports.
 *
 * @param {jQuery} $message - Message element to position the panel relative to
 * @param {Array} thoughtsArray - Array of thought objects {name, emoji, thought}
 */
export function createThoughtPanel($message, thoughtsArray) {
    // Initialize drag handlers once
    initThoughtIconDragHandlers();
    // Remove existing thought panel
    $('#rpg-thought-panel').remove();
    $('#rpg-thought-icon').remove();
    // Get the avatar position from the message
    const $avatar = $message.find('.avatar img');
    if (!$avatar.length) {
        return;
    }
    const avatarRect = $avatar[0].getBoundingClientRect();
    const panelPosition = extensionSettings.panelPosition;
    const theme = extensionSettings.theme;
    // Build thought bubbles HTML
    let thoughtsHtml = '';
    thoughtsArray.forEach((thought, index) => {
        thoughtsHtml += `
            <div class="rpg-thought-item">
                <div class="rpg-thought-emoji-box">
                    ${thought.emoji}
                </div>
                <div class="rpg-thought-content rpg-editable" contenteditable="true" data-character="${thought.name}" data-field="thoughts" title="Click to edit thoughts">
                    ${thought.thought}
                </div>
            </div>
        `;
        // Add divider between thoughts (except for last one)
        if (index < thoughtsArray.length - 1) {
            thoughtsHtml += '<div class="rpg-thought-divider"></div>';
        }
    });
    // Create the floating thought panel with theme
    const $thoughtPanel = $(`
        <div id="rpg-thought-panel" class="rpg-thought-panel" data-theme="${theme}">
            <button class="rpg-thought-close" title="Hide thoughts">√ó</button>
            <div class="rpg-thought-circles">
                <div class="rpg-thought-circle rpg-circle-1"></div>
                <div class="rpg-thought-circle rpg-circle-2"></div>
                <div class="rpg-thought-circle rpg-circle-3"></div>
            </div>
            <div class="rpg-thought-bubble">
                ${thoughtsHtml}
            </div>
        </div>
    `);
    // Create the collapsed thought icon
    const $thoughtIcon = $(`
        <div id="rpg-thought-icon" class="rpg-thought-icon" data-theme="${theme}" title="Show thoughts">
            üí≠
        </div>
    `);
    // Apply custom theme colors if custom theme
    if (theme === 'custom') {
        const customStyles = {
            '--rpg-bg': extensionSettings.customColors.bg,
            '--rpg-accent': extensionSettings.customColors.accent,
            '--rpg-text': extensionSettings.customColors.text,
            '--rpg-highlight': extensionSettings.customColors.highlight
        };
        $thoughtPanel.css(customStyles);
        $thoughtIcon.css(customStyles);
    }
    // Append to body so it's not clipped by chat container
    $('body').append($thoughtPanel);
    $('body').append($thoughtIcon);
    // Attach drag handlers to the icon
    attachDragHandlersToIcon($thoughtIcon);
    // Simple viewport-based positioning - always top-left corner
    const margin = 20;
    const topMargin = 10; // Space between ST's top bar and thought panel
    // Function to calculate top position based on ST's top bar
    const getTopPosition = () => {
        const topBar = $('#top-settings-holder');
        if (topBar.length) {
            return (topBar.outerHeight() || 140) + topMargin;
        }
        return 140 + topMargin; // Fallback
    };
    // Function to update bubble position and width
    const updateBubblePosition = () => {
        const topPosition = getTopPosition();
        const sheld = $('#sheld')[0];
        const isRightPanel = extensionSettings.panelPosition === 'right';
        // Update top position for panel (always in desktop)
        $thoughtPanel.css('top', `${topPosition}px`);
        // Update horizontal position based on panel position
        // If panel is on right, thoughts on left (default)
        // If panel is on left, thoughts on right (mirrored)
        if (isRightPanel) {
            $thoughtPanel.css({
                left: `${margin}px`,
                right: 'auto'
            }).removeClass('rpg-thought-panel-right').addClass('rpg-thought-panel-left');
        } else {
            // Panel on left, so thoughts on right
            $thoughtPanel.css({
                left: 'auto',
                right: `${margin}px`
            }).removeClass('rpg-thought-panel-left').addClass('rpg-thought-panel-right');
        }
        // Only update icon position if in desktop mode or if no saved position in mobile
        if (window.innerWidth > 1000) {
            // Desktop: update icon to match panel position (though it's hidden)
            if (isRightPanel) {
                $thoughtIcon.css({
                    left: `${margin}px`,
                    right: 'auto'
                });
            } else {
                $thoughtIcon.css({
                    left: 'auto',
                    right: `${margin}px`
                });
            }
        } else {
            // Mobile: only set default if no saved position exists
            const iconPos = extensionSettings.thoughtIconPosition;
            if (!iconPos || (!iconPos.top && !iconPos.left)) {
                // Position icon in the center of the viewport
                const defaultTop = window.innerHeight / 2;
                const defaultLeft = window.innerWidth / 2;
                $thoughtIcon.css({
                    'top': `${defaultTop}px`,
                    'left': `${defaultLeft}px`
                });
            }
        }
        // Update width based on available space
        if (sheld) {
            const sheldRect = sheld.getBoundingClientRect();
            let availableWidth;
            if (isRightPanel) {
                availableWidth = sheldRect.left - (margin * 2);
            } else {
                // Panel on left, calculate space on right
                availableWidth = window.innerWidth - sheldRect.right - (margin * 2);
            }
            const maxWidth = Math.min(350, Math.max(200, availableWidth));
            $thoughtPanel.css('max-width', `${maxWidth}px`);
        } else {
            $thoughtPanel.css('max-width', '350px');
        }
    };
    // Set initial position and width (will be updated by updateBubblePosition)
    const isRightPanel = extensionSettings.panelPosition === 'right';
    if (isRightPanel) {
        $thoughtPanel.css({
            left: `${margin}px`,
            right: 'auto'
        }).addClass('rpg-thought-panel-left');
        $thoughtIcon.css({
            left: `${margin}px`,
            right: 'auto'
        });
    } else {
        $thoughtPanel.css({
            left: 'auto',
            right: `${margin}px`
        }).addClass('rpg-thought-panel-right');
        $thoughtIcon.css({
            left: 'auto',
            right: `${margin}px`
        });
    }
    updateBubblePosition();
    // Update on window resize and when ST's layout changes
    $(window).on('resize.rpgThoughtBubble', updateBubblePosition);
    // Desktop: always show panel, hide icon
    // Mobile: show icon, hide panel initially
    const isMobileView = window.innerWidth <= 1000;
    if (isMobileView) {
        $thoughtPanel.hide();
        // Remove force-hide class to let CSS media query show icon
        $thoughtIcon.removeClass('rpg-force-hide');
        // Load saved icon position in mobile, or default to center of viewport
        if (extensionSettings.thoughtIconPosition && extensionSettings.thoughtIconPosition.top && extensionSettings.thoughtIconPosition.left) {
            const pos = extensionSettings.thoughtIconPosition;
            // Validate saved position - check if it's not at the very top (likely invalid)
            const savedTop = parseInt(pos.top);
            const topBar = $('#top-settings-holder');
            const topBarHeight = topBar.length ? topBar.outerHeight() : 60;
            // If saved position is above or too close to top bar, recalculate default
            if (savedTop < topBarHeight + 50) {
                // Clear invalid saved position
                delete extensionSettings.thoughtIconPosition;
                saveSettings();
                // Calculate new default position
                setTimeout(() => {
                    const viewportHeight = window.innerHeight;
                    const viewportWidth = window.innerWidth;
                    const defaultTop = topBarHeight + ((viewportHeight - topBarHeight) / 2) - 22;
                    const defaultLeft = (viewportWidth * 0.75) - 22;
                    //     topBarHeight,
                    //     viewportHeight,
                    //     viewportWidth,
                    //     calculatedTop: defaultTop,
                    //     calculatedLeft: defaultLeft
                    // });
                    $thoughtIcon.css({
                        top: `${defaultTop}px`,
                        left: `${defaultLeft}px`,
                        transform: 'none',
                        right: 'auto',
                        bottom: 'auto'
                    });
                }, 100);
            } else {
                // Position is valid, use it
                $thoughtIcon.css({
                    top: pos.top,
                    left: pos.left,
                    transform: 'none',
                    right: 'auto',
                    bottom: 'auto'
                });
            }
        } else {
            // Default position: center-right of viewport, accounting for top bar
            // Use setTimeout to ensure DOM is fully rendered before calculating positions
            setTimeout(() => {
                const topBar = $('#top-settings-holder');
                const topBarHeight = topBar.length ? topBar.outerHeight() : 60;
                const viewportHeight = window.innerHeight;
                const viewportWidth = window.innerWidth;
                // Position in the center vertically (accounting for top bar) and slightly right
                const defaultTop = topBarHeight + ((viewportHeight - topBarHeight) / 2) - 22; // 22 = half of icon height
                const defaultLeft = (viewportWidth * 0.75) - 22; // 75% from left, minus half icon width
                //     topBarHeight,
                //     viewportHeight,
                //     viewportWidth,
                //     calculatedTop: defaultTop,
                //     calculatedLeft: defaultLeft
                // });
                $thoughtIcon.css({
                    top: `${defaultTop}px`,
                    left: `${defaultLeft}px`,
                    transform: 'none',
                    right: 'auto',
                    bottom: 'auto'
                });
            }, 100);
        }
    } else {
        // Desktop: always start with panel expanded on page load/refresh
        $thoughtPanel.css('display', 'block');
        $thoughtIcon.addClass('rpg-force-hide').removeClass('rpg-collapsed-desktop');
    }
    // Handle viewport changes between mobile and desktop
    let wasMobileView = window.innerWidth <= 1000;
    $(window).on('resize.thoughtIconDrag', () => {
        const isMobileNow = window.innerWidth <= 1000;
        if (!wasMobileView && isMobileNow) {
            // Switched to mobile - apply saved position if exists
            const $currentIcon = $('#rpg-thought-icon');
            if (extensionSettings.thoughtIconPosition) {
                const pos = extensionSettings.thoughtIconPosition;
                if (pos.top) $currentIcon.css('top', pos.top);
                if (pos.left) $currentIcon.css('left', pos.left);
            }
        }
        // Constrain icon if in mobile view
        if (isMobileNow) {
            setTimeout(() => {
                const $currentIcon = $('#rpg-thought-icon');
                if ($currentIcon.length) {
                    constrainIconToViewport($currentIcon);
                }
            }, 10);
        }
        wasMobileView = isMobileNow;
    });
    // Close button functionality - support both click and touch
    $thoughtPanel.find('.rpg-thought-close').on('click touchend', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const isMobileView = window.innerWidth <= 1000;
        if (isMobileView) {
            // Mobile: hide panel and show icon
            $thoughtPanel.fadeOut(200, function() {
                // Make sure icon is visible and clean state when panel closes (use selector, not variable)
                const $icon = $('#rpg-thought-icon');
                $icon.removeClass('rpg-hidden dragging');
                $icon.data('just-dragged', false);
            });
        } else {
            // Desktop: collapse to icon at panel position
            const panelRect = $thoughtPanel[0].getBoundingClientRect();
            const $icon = $('#rpg-thought-icon');
            // Position icon where the panel is
            $icon.css({
                top: `${panelRect.top}px`,
                left: isRightPanel ? `${panelRect.left}px` : 'auto',
                right: isRightPanel ? 'auto' : `${window.innerWidth - panelRect.right}px`
            });
            // Mark as collapsed desktop state (session only, not persisted)
            $icon.addClass('rpg-collapsed-desktop');
            // Hide panel and show icon
            $thoughtPanel.fadeOut(200, function() {
                $icon.removeClass('rpg-hidden rpg-force-hide');
            });
        }
    });
    // Icon click/tap to show panel
    const handleThoughtIconTap = function(e) {
        const isMobileView = window.innerWidth <= 1000;
        const $icon = $('#rpg-thought-icon');
        // Desktop collapsed state: expand panel and hide icon
        if (!isMobileView && $icon.hasClass('rpg-collapsed-desktop')) {
            e.preventDefault();
            e.stopPropagation();
            // Remove collapsed state (no need to save, state is session-only)
            $icon.addClass('rpg-force-hide').removeClass('rpg-collapsed-desktop');
            // Show panel
            $('#rpg-thought-panel').fadeIn(200);
            return;
        }
        // Skip if we just finished dragging (mobile only)
        if ($thoughtIcon.data('just-dragged')) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        // In mobile view, position panel below ST's top bar and fit full screen
        if (window.innerWidth <= 1000) {
            const topBar = $('#top-settings-holder');
            const topBarHeight = topBar.length ? topBar.outerHeight() : 60;
            const topPosition = topBarHeight + 10; // 10px margin below top bar
            $thoughtPanel.css({
                top: topPosition + 'px',
                display: 'none' // Keep hidden while setting position
            });
        }
        $thoughtIcon.addClass('rpg-hidden');
        $thoughtPanel.fadeIn(200);
    };
    // Support both click and touch events for mobile
    $thoughtIcon.on('click touchend', handleThoughtIconTap);
    // Add event handlers for editable thoughts in the bubble
    $thoughtPanel.find('.rpg-editable').on('blur', function() {
        const character = $(this).data('character');
        const field = $(this).data('field');
        const value = $(this).text().trim();
        updateCharacterField(character, field, value);
    });
    // Add event listener for section lock icon clicks (support both click and touch)
    $thoughtPanel.find('.rpg-section-lock-icon').on('click touchend', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const $icon = $(this);
        const trackerType = $icon.data('tracker');
        const itemPath = $icon.data('path');
        const currentlyLocked = isItemLocked(trackerType, itemPath);
        // Toggle lock state
        setItemLock(trackerType, itemPath, !currentlyLocked);
        // Update icon
        const newIcon = !currentlyLocked ? 'üîí' : 'üîì';
        const newTitle = !currentlyLocked ? 'Locked' : 'Unlocked';
        $icon.text(newIcon);
        $icon.attr('title', newTitle);
        // Toggle 'locked' class for persistent visibility
        $icon.toggleClass('locked', !currentlyLocked);
        // Save settings
        saveSettings();
    });
    // RAF throttling for smooth position updates
    let positionUpdateRaf = null;
    // Update position on scroll with RAF throttling - DISABLED for fixed top-left positioning
    const updatePanelPosition = () => {
        // Bubble is now fixed at top-left, no need to update position on scroll
        // Just check visibility
        if (!$message.is(':visible')) {
            $thoughtPanel.hide();
            $thoughtIcon.hide();
        } else {
            if ($thoughtPanel.is(':visible')) {
                $thoughtPanel.show();
            }
            if ($thoughtIcon.is(':visible')) {
                $thoughtIcon.show();
            }
        }
    };
    // Update visibility on scroll (but not position)
    $('#chat').on('scroll.thoughtPanel', updatePanelPosition);
    // Don't listen to window resize for position - we handle width separately
    // Position stays fixed at top-left
    // Remove panel when clicking outside (mobile only)
    $(document).on('click.thoughtPanel', function(e) {
        // Only hide on click outside in mobile view
        if (window.innerWidth <= 1000) {
            if (!$(e.target).closest('#rpg-thought-panel, #rpg-thought-icon').length) {
                // Hide the panel and show the icon instead of removing (use selectors, not variables)
                $('#rpg-thought-panel').fadeOut(200);
                $('#rpg-thought-icon').removeClass('rpg-hidden').fadeIn(200);
            }
        }
    });
}
